# 1 Основні принципи ООП та їх реалізація в C#

Об'єктно-орієнтоване програмування (ООП) базується на чотирьох основних принципах: **інкапсуляція**, **наслідування**, **поліморфізм** та **абстракція**. Розгляньмо кожен із них та їх реалізацію в мові C#.

---

## 1. Інкапсуляція

**Інкапсуляція** передбачає об'єднання даних (полів) та методів, які працюють з цими даними, в одному класі, приховуючи внутрішню реалізацію від зовнішнього світу. Це забезпечує контроль доступу до даних і захист від некоректного використання.

### Реалізація в C#:

У C# для керування доступом використовуються модифікатори доступу: `public`, `private`, `protected` та `internal`. Наприклад:

```csharp
public class BankAccount
{
    private decimal balance; // поле приховане від зовнішнього доступу

    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            balance += amount;
        }
    }

    public decimal GetBalance()
    {
        return balance;
    }
}
```

У цьому прикладі поле `balance` є приватним, і доступ до нього здійснюється через публічні методи `Deposit` та `GetBalance`.

---

## 2. Наслідування

**Наслідування** дозволяє створювати нові класи на основі існуючих, успадковуючи їхні властивості та методи. Це сприяє повторному використанню коду та створенню ієрархій класів.

### Реалізація в C#:

У C# наслідування реалізується за допомогою двокрапки `:`. Наприклад:

```csharp
public class Animal
{
    public void Eat() => Console.WriteLine("Їсть...");
}

public class Dog : Animal
{
    public void Bark() => Console.WriteLine("Гавкає!");
}
```

---

## 3. Поліморфізм

**Поліморфізм** означає, що одна й та сама дія може виконуватись по-різному залежно від об’єкта. Це дозволяє створювати більш гнучкий та масштабований код.

### Реалізація в C#:

C# підтримує як **перевизначення методів** (`virtual` / `override`), так і **інтерфейси**.

```csharp
public class Animal
{
    public virtual void Speak() => Console.WriteLine("Звук тварини");
}

public class Cat : Animal
{
    public override void Speak() => Console.WriteLine("Мяу");
}
```

---

## 4. Абстракція

**Абстракція** дозволяє приховати складність реалізації та показати лише важливу частину функціональності.

### Реалізація в C#:

Використовуються **абстрактні класи** або **інтерфейси**.

```csharp
public abstract class Shape
{
    public abstract double GetArea();
}

public class Circle : Shape
{
    public double Radius { get; set; }
    public override double GetArea() => Math.PI * Radius * Radius;
}
```

---

## Висновок

| Принцип      | Реалізація в C#                                   |
| ------------ | ------------------------------------------------- |
| Інкапсуляція | Модифікатори доступу (`private`, `public` і т.д.) |
| Наслідування | Наслідування класів за допомогою `:`              |
| Поліморфізм  | `virtual`, `override`, інтерфейси                 |
| Абстракція   | `abstract` класи, інтерфейси (`interface`)        |

---
# 2. Як ці принципи реалізовані в C#?
1. **Інкапсуляція**: реалізується через модифікатори доступу (`public`, `private`, `protected`, `internal`), які контролюють видимість членів класу.

2. **Успадкування**: використовується двокрапка `:` для вказівки базового класу.

3. **Поліморфізм**: досягається через використання ключових слів `virtual` та `override` для перевизначення методів, а також через інтерфейси.

4. **Абстракція**: реалізується за допомогою абстрактних класів (`abstract`) та інтерфейсів (`interface`), які визначають загальні методи та властивості для класів-нащадків.
---
# 3. Які проблеми вирішуються підходом ООП?
- **Модульності**: код розбивається на окремі класи, що спрощує його підтримку та повторне використання.
- **Зрозумілості**: структура коду відображає реальні об'єкти та їх взаємодії, що полегшує розуміння.
- **Гнучкості та масштабованості**: легко додавати нові функціональності без значних змін існуючого коду.
---
# 4. Які недоліки ООП?
- **Перевитрати ресурсів**: створення об'єктів та використання динамічної диспетчеризації може споживати більше пам'яті та часу виконання.
- **Складність**: неправильне проектування класів та їх взаємодій може призвести до заплутаного коду.
- **Надмірність**: іноді для простих задач використання ООП може бути надлишковим.


---
# 5. Поясніть концепцію інкапсуляції в об'єктно-орієнтованому програмуванні та як її реалізувати за допомогою C#.
Інкапсуляція передбачає приховування внутрішнього стану об'єкта та надання доступу до нього лише через публічні методи. У C# це реалізується за допомогою модифікаторів доступу:

```csharp
public class BankAccount
{
    private decimal balance; // приховане поле

    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            balance += amount;
        }
    }
     public decimal GetBalance()
    {
        return balance;
    }
}
```

---
# 6. Що таке абстрактний клас? І чим відрізняється від звичайного класу?

**Абстрактний клас** — це клас, який не можна створити (інстанціювати) напряму. Він слугує шаблоном для інших класів і може містити як **реалізовані методи**, так і **абстрактні методи** (тобто без реалізації), які мають бути реалізовані в похідних класах.

### Приклад:

```csharp
public abstract class Animal
{
    public void Eat() => Console.WriteLine("Їсть");

    public abstract void MakeSound(); // без реалізації
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Гав!");
    }
}
```

### Відмінності від звичайного класу:

| Критерій                             | Абстракційний клас                         | Звичайний клас                    |
| ------------------------------------ | ------------------------------------------ | --------------------------------- |
| **Можна створювати об'єкти?**        | ❌ Ні                                       | ✅ Так                             |
| **Може містити абстрактні методи?**  | ✅ Так                                      | ❌ Ні                              |
| **Може містити реалізацію методів?** | ✅ Так                                      | ✅ Так                             |
| **Призначення**                      | Базовий клас, що задає інтерфейс/поведінку | Самостійний клас для використання |
| **Ключове слово**                    | `abstract`                                 | не потрібне                       |


---
# 7 Інтерфейси та їх відмінності від абстрактних класів у C#

**Інтерфейс** — це тип, який визначає контракт для класів або структур, що його реалізують. Він описує набір методів та властивостей, які повинні бути реалізовані в класах або структурах, але не містить реалізації цих методів.

**Основні відмінності між інтерфейсом та абстрактним класом:**

1. **Множинне успадкування:**
   - **Інтерфейс:** Клас може реалізовувати кілька інтерфейсів, що дозволяє досягати множинного успадкування.
   - **Абстрактний клас:** Клас може успадковувати лише від одного абстрактного класу, оскільки C# підтримує лише одиничне успадкування класів.

2. **Модифікатори доступу:**
   - **Інтерфейс:** Усі члени інтерфейсу за замовчуванням є `public`. Починаючи з C# 8.0, інтерфейси можуть містити приватні методи, але інші модифікатори доступу, такі як `protected` або `internal`, все ще не підтримуються для членів інтерфейсу.
   - **Абстрактний клас:** Може використовувати різні модифікатори доступу (`public`, `private`, `protected`, `internal`) для своїх членів.

3. **Реалізація методів:**
   - **Інтерфейс:** Може містити тільки оголошення методів без реалізації (до C# 8.0). Починаючи з C# 8.0, інтерфейси можуть містити методи з реалізацією за замовчуванням.
   - **Абстрактний клас:** Може містити як абстрактні методи (без реалізації), так і методи з реалізацією.

4. **Поля та дані:**
   - **Інтерфейс:** Не може містити поля даних. Може містити лише статичні константи.
   - **Абстрактний клас:** Може містити поля даних будь-якого типу.

5. **Конструктори:**
   - **Інтерфейс:** Не може мати конструкторів.
   - **Абстрактний клас:** Може мати конструктори, які можуть бути викликані з конструкторів похідних класів.

6. **Призначення використання:**
   - **Інтерфейс:** Використовується для визначення спільного контракту для різних класів, які можуть не мати спільної реалізації. Це підходить для опису поведінки, яку можуть мати різні, непов'язані між собою класи.
   - **Абстрактний клас:** Використовується, коли є спільна базова реалізація, яку слід розділяти серед похідних класів. Це підходить для створення ієрархій типів з спільними властивостями та методами.

**Приклад використання інтерфейсу та абстрактного класу:**

```csharp
// Інтерфейс
public interface IFlyable
{
    void Fly();
}

// Абстрактний клас
public abstract class Animal
{
    public string Name { get; set; }

    public void Eat()
    {
        Console.WriteLine($"{Name} їсть.");
    }

    public abstract void MakeSound();
}

// Клас, що реалізує інтерфейс та успадковує абстрактний клас
public class Bird : Animal, IFlyable
{
    public Bird(string name)
    {
        Name = name;
    }

    public override void MakeSound()
    {
        Console.WriteLine($"{Name} співає.");
    }

    public void Fly()
    {
        Console.WriteLine($"{Name} летить.");
    }
}
```


---
# 8 Ключове слово `virtual` у C#

У мові програмування C# ключове слово `virtual` використовується в об'єктно-орієнтованому програмуванні для позначення членів класу, які можуть бути перевизначені (overridden) у похідних класах. Воно є основою для реалізації поліморфізму, дозволяючи похідним класам надавати власну реалізацію методів або властивостей базового класу.

## Що дає ключове слово `virtual`?
1. **Поліморфізм**: Дозволяє викликати перевизначену версію методу або властивості з похідного класу через посилання на базовий клас.
2. **Гнучкість**: Надає можливість похідним класам змінювати або розширювати поведінку базового класу.
3. **Пізнє зв’язування**: Забезпечує вибір реалізації під час виконання програми (runtime), а не під час компіляції.

## Які члени класу можуть бути позначені модифікатором `virtual`?
У C# ключове слово `virtual` може застосовуватися до таких членів класу:
1. **Методи**:
   - Звичайні методи класу, які можуть бути перевизначені в похідних класах за допомогою ключового слова `override`.
   - Наприклад:
     ```csharp
     public class BaseClass
     {
         public virtual void Display()
         {
             Console.WriteLine("Base class");
         }
     }
     ```

2. **Властивості**:
   - Властивості (properties) можуть бути віртуальними, дозволяючи похідним класам перевизначати їхню поведінку (геттери та сеттери).
   - Наприклад:
     ```csharp
     public class BaseClass
     {
         public virtual int MyProperty { get; set; }
     }
     ```

3. **Індексатори**:
   - Індексатори (indexers) також можуть бути позначені як `virtual`, щоб дозволити їх перевизначення.
   - Наприклад:
     ```csharp
     public class BaseClass
     {
         protected int[] data = new int[10];
         public virtual int this[int index]
         {
             get => data[index];
             set => data[index] = value;
         }
     }
     ```

4. **Обмеження**:
   - Конструктори **не можуть** бути віртуальними, оскільки вони викликаються під час створення об’єкта і не беруть участі в поліморфізмі.
   - Деструктори (фіналізатори) у C# **не можуть** бути віртуальними, на відміну від C++, оскільки в C# управління пам’яттю здійснюється через збірник сміття (Garbage Collector), і деструктори мають іншу семантику.
   - Статичні члени (методи, властивості тощо) **не можуть** бути віртуальними, оскільки вони належать класу, а не екземпляру.

## Особливості в C#
- У похідному класі для перевизначення віртуального члена використовується ключове слово `override`. Наприклад:
  ```csharp
    public class DerivedClass : BaseClass
    {
        public override void Display()
        {
            Console.WriteLine("Derived class");
        }
    }
  ```
  Якщо член позначений як virtual, він може бути перевизначений лише за допомогою override. Без virtual члени за замовчуванням не є поліморфними в C# (на відміну від деяких інших мов, наприклад, Java).

Ключове слово virtual не можна комбінувати з static, abstract або private, оскільки ці модифікатори суперечать його призначенню.

### Висновок
У C# virtual є важливим інструментом для створення гнучких ієрархій класів, дозволяючи перевизначати методи, властивості та індексатори в похідних класах. Це забезпечує поліморфізм і розширюваність коду.


---
# 9 Яка різниця між перевантаженням методу та перевизначенням методу?

У мові програмування C# **перевантаження (overloading)** і **перевизначення (overriding)** методів є двома різними концепціями, які часто плутають через схожість термінів. Вони мають різні цілі, механізми та правила використання. Розглянемо їх детально.

## Перевантаження методу (Method Overloading)
**Перевантаження методу** — це створення кількох методів з однаковою назвою, але різними сигнатурами (кількістю, типами параметрів або їх порядком) у межах одного класу.

## Основні характеристики:
1. **Місце визначення**: Відбувається в межах одного класу.
2. **Сигнатура**: Методи відрізняються за параметрами (кількість, тип або порядок), але можуть мати однаковий тип повернення.
3. **Поліморфізм**: Є прикладом статичного (компіляційного) поліморфізму, оскільки вибір методу відбувається під час компіляції.
4. **Модифікатори**: Не потребує спеціальних ключових слів, таких як `virtual` чи `override`.

```csharp
   public class Calculator
   {
       public int Add(int a, int b)
       {
           return a + b;
       }

       public double Add(double a, double b)
       {
           return a + b;
       }

       public int Add(int a, int b, int c)
       {
           return a + b + c;
       }
   }
```
   У цьому прикладі метод Add перевантажений трьома різними способами.
   
## Коли використовувати?
- Коли потрібно виконувати схожу логіку з різними типами або кількістю вхідних даних.

## Перевизначення методу (Method Overriding)
**Перевизначення методу** — це зміна або розширення реалізації методу базового класу в похідному класі. Воно пов’язане з успадкуванням і поліморфізмом.

### Основні характеристики:
1. **Місце визначення**: Відбувається в похідному класі для методу, визначеного в базовому класі.
2. **Сигнатура**: Метод у похідному класі повинен мати таку саму сигнатуру (назву, параметри, тип повернення), як у базовому класі.
3. **Поліморфізм**: Є прикладом динамічного (виконавчого) поліморфізму, оскільки вибір методу відбувається під час виконання програми.
4. **Модифікатори**: У базовому класі метод позначається як virtual, а в похідному — перевизначається за допомогою override.

```csharp
  public class Animal
  {
      public virtual void MakeSound()
      {
          Console.WriteLine("Some generic sound");
      }
  }
  
  public class Dog : Animal
  {
      public override void MakeSound()
      {
          Console.WriteLine("Woof!");
      }
  }
```
У цьому прикладі метод MakeSound перевизначений у класі Dog.

## Коли використовувати?
- Коли потрібно змінити або розширити поведінку методу базового класу в похідному класі.

## Основні відмінності

| **Характеристика**   | **Перевантаження (Overloading)** | **Перевизначення (Overriding)**                  |
| -------------------- | -------------------------------- | ------------------------------------------------ |
| **Місце дії**        | У межах одного класу             | Між базовим і похідним класами                   |
| **Сигнатура**        | Різні параметри (кількість, тип) | Та сама сигнатура                                |
| **Тип поліморфізму** | Статичний (компіляційний)        | Динамічний (виконавчий)                          |
| **Ключові слова**    | Не потрібні                      | `virtual` (базовий), `override` (похідний)       |
| **Успадкування**     | Не залежить від успадкування     | Потребує успадкування                            |
| **Приклад виклику**  | `Add(1, 2)` vs `Add(1.0, 2.0)`   | `animal.MakeSound()` (залежить від типу об’єкта) |


## Висновок
- **Перевантаження** дозволяє створювати кілька версій методу з різними параметрами для зручності використання в одному класі.
- **Перевизначення** дозволяє адаптувати поведінку методу базового класу до потреб похідного класу, забезпечуючи поліморфізм.
Обидва підходи є важливими інструментами в C#, але вони вирішують різні задачі та застосовуються в різних контекстах.

---
# 10 Що таке Upcast і Downcast у C#?

У мові програмування C# терміни **upcast** і **downcast** відносяться до приведення типів (type casting) у контексті успадкування класів. Вони описують, як об’єкти можуть бути приведені до типів у межах ієрархії класів — від базового до похідного типу або навпаки.

---

## Upcast (Приведення вгору)
**Upcast** — це приведення об’єкта похідного класу до типу базового класу. Це завжди безпечний процес, який не потребує явного приведення, оскільки похідний клас успадковує всі члени базового класу.

### Основні характеристики:
1. **Напрямок**: Від похідного класу до базового класу (вгору по ієрархії).
2. **Безпека**: Завжди безпечний і виконується автоматично (implicitly).
3. **Синтаксис**: Не потребує явного приведення типів.
4. **Приклад**:
   ```csharp
   public class Animal
   {
       public void MakeSound()
       {
           Console.WriteLine("Some sound");
       }
   }

   public class Dog : Animal
   {
       public void Bark()
       {
           Console.WriteLine("Woof!");
       }
   }

   class Program
   {
       static void Main()
       {
           Dog dog = new Dog();
           Animal animal = dog; // Upcast (неявне приведення)
           animal.MakeSound(); // Виведе: "Some sound"
           // animal.Bark(); // Помилка: Animal не має методу Bark
       }
   }
    ```
5. **Обмеження**: Після upcast доступні лише члени базового класу, навіть якщо об’єкт є екземпляром похідного класу.

### Коли використовувати?
- Коли потрібно працювати з об’єктами похідних класів через інтерфейс базового класу (наприклад, у поліморфізмі).

## Downcast (Приведення вниз)
**Downcast** — це приведення об’єкта базового класу до типу похідного класу. Це небезпечний процес, який потребує явного приведення, оскільки не кожен об’єкт базового класу є екземпляром похідного класу.
### Основні характеристики:
1. **Напрямок**: Від базового класу до похідного класу (вниз по ієрархії).

2. **Безпека**: Не завжди безпечний; може викликати виняток InvalidCastException, якщо об’єкт не є екземпляром цільового типу.

3. **Синтаксис**: Потребує явного приведення типів (explicit casting) або використання операторів as чи is.

4. **Приклад**:
```csharp

    public class Animal
    {
        public virtual void MakeSound()
        {
            Console.WriteLine("Some sound");
        }
    }

    public class Dog : Animal
    {
        public override void MakeSound()
        {
            Console.WriteLine("Woof!");
        }
    }

    class Program
    {
        static void Main()
        {
            Animal animal = new Dog(); // Upcast
            Dog dog = (Dog)animal;    // Downcast (явне приведення)
            dog.MakeSound();          // Виведе: "Woof!"

            // Перевірка типу перед downcast
            if (animal is Dog)
            {
                Dog anotherDog = (Dog)animal;
                anotherDog.MakeSound(); // Виведе: "Woof!"
            }

            // Використання оператора as
            Dog safeDog = animal as Dog;
            if (safeDog != null)
            {
                safeDog.MakeSound(); // Виведе: "Woof!"
            }
        }
    }
```

5. **Обмеження**: Downcast можливий лише тоді, коли об’єкт насправді є екземпляром похідного класу. Інакше виникне помилка.

### Способи безпечного downcast:
- **Оператор `is`**: Перевіряє, чи є об’єкт сумісним із типом перед приведенням.
- **Оператор `as`**: Повертає `null`, якщо приведення неможливе, замість викидання винятку.
- **Pattern matching** (C# 7.0+):
   ```csharp
   if (animal is Dog dogFromPattern)
   {
       dogFromPattern.MakeSound(); // Виведе: "Woof!"
   }
   ```

### Коли використовувати?
- Коли потрібно отримати доступ до специфічних членів похідного класу, які недоступні через тип базового класу.

## Основні відмінності

| **Характеристика**    | **Upcast**                          | **Downcast**                        |
|-----------------------|-------------------------------------|-------------------------------------|
| **Напрямок**          | Від похідного до базового          | Від базового до похідного          |
| **Безпека**           | Завжди безпечний                  | Небезпечний, може викликати помилку |
| **Приведення**        | Неявне (implicit)                 | Явне (explicit)                    |
| **Доступ до членів**  | Обмежено базовим класом           | Доступ до членів похідного класу   |
| **Приклад**           | `Animal animal = dog;`            | `Dog dog = (Dog)animal;`           |

### Висновок
**Upcast** є природним і безпечним способом роботи з об’єктами в ієрархії класів, часто використовується для поліморфізму.

**Downcast** потрібен для доступу до специфічної функціональності похідного класу, але вимагає обережності та перевірки типів.

Обидва механізми є важливими для роботи з успадкуванням і поліморфізмом у C#.

# 11 Що таке події та делегати? Яка основна різниця між ними? Як їх використовувати для реалізації зворотного виклику в C#?

### Основна різниця між подіями та делегатами:

| **Характеристика**       | **Події (Events)**                                                                 | **Делегати (Delegates)**                                                |
|--------------------------|------------------------------------------------------------------------------------|-------------------------------------------------------------------------|
| **Інкапсуляція**         | Події забезпечують кращу інкапсуляцію механізму зворотного виклику.                | Делегат є просто посиланням на метод, яке можна перезаписати.           |
| **Контроль доступу**     | Зовнішні класи можуть лише підписуватися та відписуватися від події.               | Делегат можна викликати або змінювати без обмежень.                     |
| **Керування викликами**  | Клас, який оголошує подію, вирішує, коли і як викликати обробники подій.           | Відповідальність за виклик делегата лежить на тому, хто володіє посиланням. |

---

### Використання подій та делегатів для реалізації зворотного виклику:

1. **Оголосіть тип делегата**, який визначає сигнатуру методу зворотного виклику.
2. **Оголосіть подію** в класі, який буде ініціювати подію. Типом події повинен бути оголошений раніше делегат.
3. Інші класи можуть створити методи, сигнатури яких відповідають оголошеному делегату. Ці методи будуть обробниками події.
4. **Об'єкти-обробники підписуються на подію** за допомогою оператора `+=`, передаючи свій метод-обробник.
5. Коли в ініціюючому класі відбувається певна подія, він викликає подію (зазвичай викликаючи делегат події). **Всі підписані методи-обробники будуть автоматично викликані.**
6. **Об'єкти-обробники можуть відписатися від події** за допомогою оператора `-=`.

---

### Приклад використання подій та делегатів для зворотного виклику:

```csharp
using System;

// 1. Оголошення делегата
public delegate void ButtonClickedEventHandler(object sender, EventArgs e);

public class Button
{
    public string Name { get; set; }

    // 2. Оголошення події
    public event ButtonClickedEventHandler Clicked;

    public Button(string name)
    {
        Name = name;
    }

    public void SimulateClick()
    {
        Console.WriteLine($"Кнопка '{Name}' натиснута.");
        // 5. Виклик події (якщо є підписники)
        Clicked?.Invoke(this, EventArgs.Empty);
    }
}

public class EventHandlerClass
{
    public void Button1_Clicked(object sender, EventArgs e)
    {
        Console.WriteLine("Обробник 1: Кнопка була натиснута!");
    }

    public void Button2_Clicked(object sender, EventArgs e)
    {
        Console.WriteLine("Обробник 2: Дякую за натискання кнопки.");
    }
}

public class Example
{
    public static void Main(string[] args)
    {
        Button button1 = new Button("Кнопка 1");
        Button button2 = new Button("Кнопка 2");
        EventHandlerClass handler = new EventHandlerClass();

        // 4. Підписка на подію
        button1.Clicked += handler.Button1_Clicked;
        button1.Clicked += handler.Button2_Clicked; // Кілька обробників

        button2.Clicked += handler.Button2_Clicked;

        button1.SimulateClick();
        Console.WriteLine();
        button2.SimulateClick();

        // Відписка від події
        button1.Clicked -= handler.Button1_Clicked;
        Console.WriteLine();
        button1.SimulateClick(); // Буде викликано лише Button2_Clicked
    }
}
```
### Пояснення прикладу:

1. **ButtonClickedEventHandler** є типом делегата, який визначає сигнатуру методів-обробників події.
2. Клас **Button** має подію **Clicked**, яка використовує цей делегат.
3. Клас **EventHandlerClass** містить два методи-обробники: **Button1_Clicked** та **Button2_Clicked**. Ці методи підписуються на подію **Clicked** кнопки **button1**.
4. Коли викликається метод **SimulateClick()** у класі **Button**, подія **Clicked** активується. Це призводить до автоматичного виклику всіх методів-обробників, які підписані на цю подію.
5. У прикладі показано, як можна підписуватися на подію за допомогою оператора `+=` і відписуватися за допомогою оператора `-=`.

Таким чином, події та делегати дозволяють реалізувати механізм зворотного виклику, забезпечуючи гнучкість і інкапсуляцію в об'єктно-орієнтованому програмуванні.



# 12 У чому різниця між масивом (`T[]`) та списком (`List<T>`)? Що таке колекції і як їх використовувати?

**Масиви (`T[]`)**

*   В C# масив є базовим класом для всіх масивів і належить до простору імен `System` [1].
*   Масив оголошується із зазначенням **конкретного розміру**, який визначає кількість елементів, які він може зберігати [2]. Розмір масиву є фіксованим і не може бути змінений під час виконання програми [3].
*   Масиви можуть бути оголошені з ініціалізацією елементів без явного використання оператора `new` [4].
    ```csharp
    int[] numbers = { 1, 2, 3, 4, 5 }; // Ініціалізація масиву
    string[] names = new string[5]; // Оголошення масиву на 3 елементи
    ```
*   Доступ до елементів масиву здійснюється за **індексом**, починаючи з нуля [2, 6].
*   Усі масиви в C# неявно перетворюються на форму інтерфейсу `IEnumerable<T>`, що дозволяє використовувати їх як джерела даних для LINQ-запитів [7-9].

**Список (`List<T>`)**

*   `List<T>` є **узагальненим еквівалентом** необобщеної колекції `ArrayList` і знаходиться в просторі імен `System.Collections.Generic` [10].
*   На відміну від масивів, `List<T>` підтримує **динамічні масиви**, які розширюються або скорочуються за необхідності [3, 11, 12].
*   Клас `List<T>` реалізує ряд інтерфейсів, включаючи `IList<T>`, `ICollection<T>`, `IEnumerable<T>` [13].
*   Елементи до списку додаються за допомогою методу `Add()` [14]. Існує також метод `AddRange()` для додавання елементів з іншої колекції [14].
    ```csharp
    List<int> numbers = new List<int>();
    numbers.Add(1);
    numbers.Add(2);
    List<int> moreNumbers = new List<int> { 3, 4 };
    numbers.AddRange(moreNumbers);
    ```
*   Доступ до елементів списку також здійснюється за індексом за допомогою індексатора `this[int index]` [15].
*   `List<T>` надає такі методи, як `BinarySearch()`, `Contains()`, `IndexOf()`, `Remove()`, `Sort()` [14, 16].

**Колекції**

*   **Колекції** в C# являють собою класи, призначені для зберігання та керування групами об'єктів [17].
*   Бібліотека класів C# (яка є частиною .NET Framework) містить велику кількість колекцій, що знаходяться в просторах імен `System.Collections` (неузагальнені колекції) та `System.Collections.Generic` (узагальнені колекції) [10, 17, 18].
*   Основоположним для всіх колекцій є поняття **перелічувача (enumerator)**, яке підтримується інтерфейсами `IEnumerator`, `IEnumerable`, `IEnumerator<T>`, `IEnumerable<T>` [17, 19]. Перелічувач надає стандартний спосіб послідовного доступу до елементів колекції [17].
*   Узагальнені колекції (`System.Collections.Generic`) є **типобезпечними** на етапі компіляції та часто **продуктивніші** за неузагальнені, оскільки дозволяють працювати зі значимими типами без упаковки/розпаковки [20].
*   Приклади неузагальнених колекцій: `ArrayList` (динамічний масив), `Hashtable` (хеш-таблиця), `Queue` (черга), `Stack` (стек), `SortedList` (відсортований список ключ-значення) [3].
*   Приклади узагальнених колекцій: `List<T>` (узагальнений список), `Dictionary<TKey, TValue>` (узагальнений словник/хеш-таблиця), `Queue<T>` (узагальнена черга), `Stack<T>` (узагальнений стек), `SortedList<TKey, TValue>` (узагальнений відсортований список ключ-значення) [10].
*   Для використання колекцій необхідно **створити екземпляр** відповідного класу колекції та **додавати до нього елементи** за допомогою наданих методів. Для перебору елементів колекції зазвичай використовується цикл `foreach` або перелічувач [19, 21].

```csharp
using System.Collections.Generic;
using System;

public class Example
{
    public static void Main(string[] args)
    {
        // Використання List<T>
        List<string> names = new List<string>();
        names.Add("Alice");
        names.Add("Bob");

        Console.WriteLine("Список імен:");
        foreach (string name in names)
        {
            Console.WriteLine(name);
        }

        // Використання Dictionary<TKey, TValue>
        Dictionary<string, int> ages = new Dictionary<string, int>();
        ages.Add("Alice", 30);
        ages.Add("Bob", 25);

        Console.WriteLine("\nВік:");
        foreach (KeyValuePair<string, int> pair in ages)
        {
            Console.WriteLine($"{pair.Key}: {pair.Value}");
        }
    }
}
```


# 13 Що таке хеш-таблиця? Що таке хеш-функція? Як обробляються колізії в словниках?

#### Хеш-таблиця
- **Хеш-таблиця** (також відома як словник) — це структура даних, яка зберігає дані у вигляді пар "ключ-значення".
- Клас `Hashtable` знаходиться в просторі імен `System.Collections`, а узагальнений еквівалент `Dictionary<TKey, TValue>` — в `System.Collections.Generic`.
- Інформація в хеш-таблиці зберігається за допомогою механізму, що називається **хешуванням**.

#### Хеш-функція
- При хешуванні для визначення унікального значення, що називається **хеш-кодом**, використовується інформаційний вміст спеціального ключа.
- Хеш-код, отриманий у результаті застосування хеш-функції до ключа, служить індексом, за яким у таблиці зберігаються відповідні цьому ключу дані.
- Перетворення ключа в хеш-код виконується автоматично, і сам хеш-код зазвичай недоступний користувачеві.
- Кожен об'єкт в C# має метод `GetHashCode()`, який повертає хеш-код, пов'язаний з об'єктом. Об'єкти з однаковим значенням повинні повертати однакові хеш-коди.
- Стандартна реалізація `GetHashCode()` в `System.Object` повертає число, яке однозначно ідентифікує об'єкт у межах домену застосунку.

#### Обробка колізій у словниках
- **Колізія** виникає тоді, коли різні ключі хешуються в один і той же хеш-код.
- Джерела явно не описують механізми обробки колізій у класах `Hashtable` та `Dictionary<TKey, TValue>`.
- Однак загальноприйняті методи обробки колізій у хеш-таблицях включають:
  - **Окремі ланцюжки (Separate Chaining)**:  
    Кожен індекс масиву хеш-таблиці містить покажчик на зв'язаний список (або іншу колекцію) ключів, які мають однаковий хеш-код.  
    При пошуку спочатку визначається індекс за хеш-кодом, а потім перебирається відповідний список для знаходження потрібного ключа.
  - **Відкрита адресація (Open Addressing)**:  
    У випадку колізії здійснюється пошук наступної вільної комірки в масиві за певним правилом (наприклад, лінійне зондування, квадратичне зондування, подвійне хешування).
- Клас `Hashtable` реалізує інтерфейс `IDictionary`, а `Dictionary<TKey, TValue>` — `IDictionary<TKey, TValue>`, які визначають основні операції для словників (додавання, видалення, пошук за ключем).  
  Внутрішня реалізація обробки колізій залишається за класами колекцій.

```csharp
using System.Collections.Generic;
using System;

public class Example
{
    public static void Main(string[] args)
    {
        Dictionary<string, string> translations = new Dictionary<string, string>();
        translations.Add("hello", "привіт");
        translations.Add("world", "світ");

        if (translations.ContainsKey("hello"))
        {
            Console.WriteLine($"Переклад 'hello': {translations["hello"]}");
        }
    }
}
```

 14. Що таке Boxing і Unboxing?

### Boxing (упаковка)
- **Boxing (упаковка)** — це процес перетворення значимого типу (value type) в посилальний тип (reference type) `System.Object` або будь-який інтерфейс, який реалізує значимий тип.
- Під час упаковки в керованій купі (managed heap) виділяється пам'ять для зберігання значення значимого типу та створюється об'єкт-посилання на це значення.
- Значення значимого типу копіюється в щойно виділену пам'ять у купі.
- Повертається адреса цього об'єкта, тобто значимий тип перетворюється на посилальний.
- Компілятор C# автоматично генерує IL-код, необхідний для упаковки, коли значимий тип передається в контекст, що очікує посилальний тип (наприклад, при додаванні значимого типу до необобщеної колекції `ArrayList`).

### Unboxing (розпаковка)
- **Unboxing (розпаковка)** — це процес зворотного перетворення з упакованого посилального типу `System.Object` або інтерфейсу на початковий значимий тип.
- Розпаковка включає два етапи:
  1. **Перевірка типу**: Перевіряється, чи є упакований об'єкт екземпляром потрібного значимого типу.
  2. **Копіювання значення**: Якщо перевірка типу пройшла успішно, значення з упакованого об'єкта копіюється в змінну значимого типу в стеку.
- Необхідно виконати **явне приведення типу (cast)** при розпаковці.

---

### Приклад Boxing та Unboxing

```csharp
using System;
using System.Collections;

public class Example
{
    public static void Main(string[] args)
    {
        int value = 123;

        // Boxing: перетворення int (значимий тип) в object (посилальний тип)
        object boxedValue = value;

        // Unboxing: перетворення object назад в int (необхідне явне приведення типу)
        int unboxedValue = (int)boxedValue;

        Console.WriteLine($"Початкове значення: {value}");
        Console.WriteLine($"Упаковане значення (тип {boxedValue.GetType()}): {boxedValue}");
        Console.WriteLine($"Розпаковане значення (тип {unboxedValue.GetType()}): {unboxedValue}");

        // Приклад з необобщеною колекцією ArrayList
        ArrayList list = new ArrayList();
        list.Add(value); // Автоматична упаковка при додаванні int до ArrayList

        int retrievedValue = (int)list[0]; // Явна розпаковка при отриманні значення
        Console.WriteLine($"Значення з ArrayList: {retrievedValue}");
    }
}
```
### Важливо
Boxing та unboxing можуть призводити до зниження продуктивності, оскільки включають операції виділення пам'яті в купі та копіювання значень. 

#### Як уникнути проблем із продуктивністю:
- Використовуйте **узагальнені колекції** (`List<T>`, `Dictionary<TKey, TValue>` тощо), які дозволяють працювати зі значимими типами без упаковки/розпаковки.
- Узагальнені колекції забезпечують:
  - **Типобезпечність** на етапі компіляції.
  - **Підвищену продуктивність**, оскільки виключають необхідність у boxing та unboxing.

#### Приклад:
```csharp
using System;
using System.Collections.Generic;

public class Example
{
    public static void Main(string[] args)
    {
        // Узагальнена колекція List<T>
        List<int> numbers = new List<int>();
        numbers.Add(123); // Додавання значення без упаковки

        int value = numbers[0]; // Отримання значення без розпаковки
        Console.WriteLine($"Значення: {value}");
    }
}
```
# 14 Які особливості використання запису (record) і запису-структури (record struct)?



У C# `record` та `record struct` — це типи, які дозволяють легко створювати **незмінні типи з порівнянням за значенням**. Вони зʼявились у C# 9 та C# 10 відповідно.

---

## `record` (reference type)

```csharp
public record Person(string Name, int Age);
```

### Особливості:

- Тип **reference** — передається за посиланням.
- За замовчуванням **immutable**: ініціалізація лише через конструктор.
- Має реалізовані методи: `Equals`, `GetHashCode`, `ToString` на основі значень властивостей.
- Підтримує `with`-вираз для створення копій з модифікацією:

```csharp
var p1 = new Person("Anna", 30);
var p2 = p1 with { Age = 31 };
```

- Можна використовувати `init`:

```csharp
public record Person
{
    public string Name { get; init; }
    public int Age { get; init; }
}
```

---

##  `record struct` (value type)

```csharp
public readonly record struct Point(int X, int Y);
```

### Особливості:

- Тип **value** — передається за значенням.
- Підтримує `with`, `Equals`, `ToString`, `Deconstruct`.
- Можна зробити повністю незмінним за допомогою `readonly`:

```csharp
public readonly record struct Coordinates(double Latitude, double Longitude);
```

---

##  Порівняння `record` vs `record struct`

| Порівняння                | `record`                      | `record struct`                 |
|--------------------------|-------------------------------|---------------------------------|
| Тип                      | Reference type                | Value type                      |
| Передача                 | За посиланням                 | За значенням                    |
| Використання памʼяті     | Купа (Heap)                   | Стек (Stack) (якщо малий тип)  |
| Immutable за замовчуванням | Так                          | Так, якщо `readonly`            |
| `with` підтримка         | ✅                            | ✅                              |
| Порівняння значень       | ✅                            | ✅                              |
| Вартість копіювання      | Дешева для reference type     | Дешева для маленьких struct     |

---

##  Коли використовувати?

### `record`:
- використовується для створення незмінних типів, які передаються за посиланням

### `record struct`:
- Коли важлива продуктивність (менше алокацій, дешеве копіювання).
- Для маленьких, часто використовуваних об’єктів.



## 15. Що дає ключове слово «static»? Яка особливість статичних класів?

Ключове слово `static` в C# використовується для оголошення статичних членів типу. Статичні члени (поля, методи, властивості, події, конструктори) пов'язані з самим типом, а не з конкретним екземпляром цього типу.

---

### Основні особливості використання `static`:

#### Статичні поля:
- Існує лише одна копія статичного поля, спільна для всіх екземплярів класу (якщо вони існують).
- Доступ до статичного поля здійснюється безпосередньо через ім'я класу, а не через екземпляр об'єкта.
- Статичні поля часто використовуються для зберігання глобальних даних або даних, спільних для всіх об'єктів певного типу.

#### Статичні методи:
- Можуть бути викликані без створення екземпляра класу.
- Не мають доступу до нестатичних членів екземпляра класу (полів, методів, властивостей), оскільки не пов'язані з конкретним об'єктом.
- Часто використовуються для реалізації утилітних функцій або операцій, які не залежать від стану конкретного об'єкта.  
  Наприклад, методи класу `System.Math` (наприклад, `Abs()`) є статичними.

#### Статичні властивості:
- Поводяться подібно до статичних полів, але надають контрольований доступ до значення.
- Доступ здійснюється безпосередньо через ім'я класу.

#### Статичні події:
- Пов'язані з самим класом, а не з окремими об'єктами.
- Для підписки на статичну подію також не потрібен екземпляр класу.

#### Статичні конструктори (конструктори типів):
- Виконуються лише один раз, при першому зверненні до типу (створення першого екземпляра або звернення до будь-якого статичного члена).
- Використовуються для ініціалізації статичних полів класу.
- Не можуть мати модифікаторів доступу та параметрів.

#### Статичні класи:
- Оголошуються за допомогою ключових слів `static class`.
- Можуть містити лише статичні члени.
- Не можуть бути інстанційовані (не можна створити об'єкт статичного класу).
- За своєю суттю є контейнерами для статичних методів, полів, властивостей тощо, що надають глобальні утилітні функції.  
  Прикладом статичного класу є клас `System.Console` (з його методами `WriteLine()`, `ReadLine()`) та `System.Math`.

---

### Приклад використання `static`:

```csharp
using System;

public static class MathUtils
{
    public static double Pi { get; } = 3.14159;

    public static int Square(int number)
    {
        return number * number;
    }
}

public class MyClass
{
    public static int counter = 0;

    public MyClass()
    {
        counter++;
    }

    public static void PrintCounter()
    {
        Console.WriteLine($"Кількість створених об'єктів MyClass: {counter}");
    }

    public void PrintPiFromUtils()
    {
        Console.WriteLine($"Значення Pi з MathUtils: {MathUtils.Pi}");
    }
}

public class Example
{
    public static void Main(string[] args)
    {
        Console.WriteLine($"Pi: {MathUtils.Pi}");
        int sq = MathUtils.Square(5);
        Console.WriteLine($"Квадрат числа 5: {sq}");

        MyClass obj1 = new MyClass();
        MyClass obj2 = new MyClass();
        MyClass.PrintCounter();

        obj1.PrintPiFromUtils();
    }
}
```

## 16. Що дає ключове слово «sealed»?

Ключове слово `sealed` в C# використовується для запобігання успадкуванню класу або перевизначенню віртуального члена в похідному класі.

---

### Основні випадки використання `sealed`:

#### Для класів:
- Якщо клас оголошено як `sealed`, від нього не можна успадковуватися. Це означає, що неможливо створити новий клас, який би розширював функціональність `sealed` класу.
- Використання `sealed` може бути корисним для запобігання випадковим або небажаним змінам у поведінці класу через успадкування.
- Компілятори можуть виконувати оптимізацію при роботі з `sealed` класами, оскільки відомо, що їх віртуальні методи не будуть перевизначені.
- За замовчуванням більшість компіляторів (включаючи C#) не роблять класи запечатаними, вважаючи, що програміст сам може запечатати клас за необхідності.

#### Для методів та властивостей:
- Ключове слово `sealed` може використовуватися для віртуальних методів або властивостей у похідному класі, щоб заборонити їх подальше перевизначення в наступних рівнях ієрархії успадкування.
- `sealed` член може бути оголошений лише в класі, який сам успадковується від іншого класу та перевизначає віртуальний член базового класу.

---

### Приклади використання `sealed`:

```csharp
using System;

// Базовий клас
public class BaseClass
{
    public virtual void SomeMethod()
    {
        Console.WriteLine("BaseClass.SomeMethod()");
    }
}

// Похідний клас, який перевизначає віртуальний метод
public class DerivedClass : BaseClass
{
    public sealed override void SomeMethod()
    {
        Console.WriteLine("DerivedClass.SomeMethod()");
    }
}

// Спроба успадкування від класу, який містить sealed override метод, є помилкою компіляції
// public class AnotherDerivedClass : DerivedClass
// {
//     public override void SomeMethod() // Помилка: неможливо перевизначити sealed метод
//     {
//         Console.WriteLine("AnotherDerivedClass.SomeMethod()");
//     }
// }

// Запечатаний клас
public sealed class SealedClass
{
    public void AnotherMethod()
    {
        Console.WriteLine("SealedClass.AnotherMethod()");
    }
}

// Спроба успадкування від запечатаного класу є помилкою компіляції
// public class YetAnotherClass : SealedClass // Помилка: 'SealedClass' є запечатаним і не може бути базовим класом
// {
//
// }

public class Example
{
    public static void Main(string[] args)
    {
        BaseClass bc = new DerivedClass();
        bc.SomeMethod(); // Викличе DerivedClass.SomeMethod()

        SealedClass sc = new SealedClass();
        sc.AnotherMethod();
    }
}
```
### Висновок:

- Використання `sealed` допомагає контролювати ієрархію успадкування та забезпечити передбачувану поведінку класів.
- Це також може покращити продуктивність програми, оскільки компілятор може виконувати оптимізації для `sealed` класів і методів.



# 17 Яка різниця між типами значень і типами посилань? Коли який тип доцільно використовувати? Наведіть приклади неправильного використання типу посилання.
В C# існує дві основні категорії типів даних: **типи значень** (value types) та **типи посилань** (reference types).

---
## Типи значень:

- **Зберігають безпосередньо свої значення у пам'яті.**
- Розміщуються в **стеку** (або вбудовані всередину типу посилання, в якому вони оголошені).
- При присвоєнні змінній одного типу значення іншої змінної того ж типу відбувається **копіювання значення**.
- До типів значень належать:
  - Усі прості типи: `int`, `float`, `decimal`, `bool`, `char`.
  - Структури (`struct`).
  - Перерахування (`enum`).
- Усі типи значень неявно є похідними від `System.ValueType`, який, у свою чергу, є похідним від `System.Object`.

---

## Типи посилань:

- **Зберігають посилання (адресу в пам'яті) на об'єкт, який містить дані.**
- Самі посилання розміщуються в **стеку**, а об'єкти розміщуються в **керованій купі (heap)**.
- При присвоєнні змінній одного типу посилання іншої змінної того ж типу відбувається **копіювання посилання**, тобто обидві змінні вказують на один і той самий об'єкт у пам'яті. Зміна об'єкта через одну змінну відобразиться і для іншої.
- До типів посилань належать:
  - Класи (`class`).
  - Інтерфейси (`interface`).
  - Масиви (`array`).
  - Делегати (`delegate`).
  - Рядки (`string`) (хоча `string` поводиться подібно до типу значення в деяких операціях, наприклад, при присвоєнні створюється нова копія).
- Усі типи посилань неявно або явно є похідними від `System.Object`.

---
## Коли який тип доцільно використовувати:
• **Типи значень** доцільно використовувати для представлення простих даних, таких як числа, логічні значення, символи, дати та часи. Вони забезпечують кращу продуктивність при передачі та зберіганні, оскільки не потребують розіменування посилання та виділення пам'яті в купі. Використовуйте структури (struct) для створення власних типів значень, які представляють невеликі об'єкти з семантикою значення. Перерахування (enum) корисні для представлення набору іменованих констант.

• **Типи посилань** доцільно використовувати для представлення складних об'єктів, які мають стан та поведінку. Класи (class) є основним механізмом для створення об'єктно-орієнтованих програм. Інтерфейси визначають контракти, які можуть реалізовувати класи та структури. Масиви використовуються для зберігання колекцій елементів одного типу фіксованого розміру. Делегати використовуються для представлення посилань на методи. Рядки (string) використовуються для представлення текстових даних. Типи посилань корисні, коли потрібно спільно використовувати дані між різними частинами програми, оскільки кілька змінних можуть посилатися на один і той самий об'єкт.

## Приклади неправильного використання типу посилання:
-  **Ненавмисна зміна спільного стану:** Якщо кілька змінних типу посилання посилаються на один і той самий об'єкт, зміна стану цього об'єкта через одну змінну може несподівано вплинути на поведінку інших частин програми, які використовують інші посилання на той самий об'єкт.  У цьому випадку використання типу посилання призвело до того, що зміна `counter2` неявно змінила стан `counter1`. Якщо б Counter був структурою (типом значення), то `counter2` отримав би копію стану `counter1`, і їхні зміни були б незалежними.
-  **Надмірне створення невеликих об'єктів-посилань:** Для простих даних, які представляють єдине значення, використання типу значення (наприклад, структури) може бути ефективнішим, ніж створення об'єкта-посилання в купі, особливо якщо такі об'єкти створюються у великій кількості. Це може призвести до збільшення навантаження на збирач сміття (`garbage collector`). Однак, рішення про використання структури замість класу слід приймати з урахуванням розміру та поведінки типу.
-  **Залежність від ідентичності об'єктів:** Іноді програмісти можуть помилково покладатися на те, що дві різні змінні типу посилання, які випадково містять однакові дані, є одним і тим самим об'єктом (порівняння за посиланням). Для порівняння вмісту об'єктів зазвичай потрібно перевизначити метод `Equals()` (і відповідно `GetHashCode()`). Оператор `==` за замовчуванням порівнює посилання для типів посилань (за винятком `string`, де він порівнює вміст).

# 18 Які типи даних доступні в C#? І в чому різниця між ними?

В C# доступні наступні основні категорії типів даних:

---

## Типи значень (Value Types):

- **Цілочисельні (Integral):**
  - `sbyte`: 8-розрядне ціле число зі знаком (від -128 до 127).
  - `byte`: 8-розрядне ціле число без знака (від 0 до 255).
  - `short` (`Int16`): 16-розрядне ціле число зі знаком (від -32 768 до 32 767).
  - `ushort` (`UInt16`): 16-розрядне ціле число без знака (від 0 до 65 535).
  - `int` (`Int32`): 32-розрядне ціле число зі знаком (від -2 147 483 648 до 2 147 483 647).
  - `uint` (`UInt32`): 32-розрядне ціле число без знака (від 0 до 4 294 967 295).
  - `long` (`Int64`): 64-розрядне ціле число зі знаком (від -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807).
  - `ulong` (`UInt64`): 64-розрядне ціле число без знака (від 0 до 18 446 744 073 709 551 615).

- **Типи з плаваючою комою (Floating-Point):**
  - `float` (`Single`): 32-розрядне число з плаваючою комою одинарної точності.
  - `double` (`Double`): 64-розрядне число з плаваючою комою подвійної точності.

- **Десятковий (Decimal):**
  - `decimal` (`Decimal`): 128-розрядний тип даних, призначений для фінансових розрахунків. Має вищу точність і менший діапазон, ніж `double`.

- **Символьний (Character):**
  - `char` (`Char`): 16-розрядний символ Unicode.

- **Логічний (Boolean):**
  - `bool` (`Boolean`): Представляє два значення: `true` (істина) або `false` (хибність).

---

## Типи посилань (Reference Types):

- **Об'єктний (Object):**
  - `object` (`Object`): Базовий тип для всіх інших типів в C#, включаючи типи значень. Змінній типу `object` можна присвоїти значення будь-якого іншого типу.

- **Рядковий (String):**
  - `string` (`String`): Представляє незмінну послідовність символів Unicode.

- **Динамічний (Dynamic):**
  - `dynamic` (`Object`): Тип, перевірка якого відбувається під час виконання програми. Для CLR тип `dynamic` ідентичний типу `object`, але компілятор C# дозволяє використовувати спрощений синтаксис для динамічного розпізнавання типів.

- **Класи (Classes):**
  - Визначаються користувачем типи посилань, які можуть містити поля, методи, властивості, події тощо.

- **Інтерфейси (Interfaces):**
  - Визначають контракт, який повинні реалізовувати інші типи.

- **Масиви (Arrays):**
  - Колекції елементів одного типу фіксованого розміру.

- **Делегати (Delegates):**
  - Типи, що представляють посилання на методи.

---

## Основні відмінності між типами даних:

- **Розмір у пам'яті:** Різні типи даних займають різний обсяг пам'яті.
- **Діапазон значень:** Кожен числовий тип має свій діапазон допустимих значень.
- **Точність:** Типи з плаваючою комою (`float`, `double`) призначені для наближеного представлення дійсних чисел і можуть мати обмежену точність, на відміну від `decimal`, який забезпечує вищу точність для фінансових розрахунків.
- **Категорія (значення/посилання):** Як описано в попередньому питанні, це визначає спосіб зберігання та передачі даних.
- **Можливості:** Різні типи даних підтримують різні операції та методи. Наприклад, з числовими типами можна виконувати арифметичні операції, а рядки мають методи для маніпуляції текстом.

---

Компілятор C# напряму підтримує так звані примітивні типи, які мають прямі аналоги в бібліотеці класів .NET Framework (FCL). Наприклад, `int` в C# відповідає `System.Int32`. Використання ключових слів C# для примітивних типів є більш зручним синтаксисом, ніж використання повних імен типів FCL, але обидва варіанти компілюються в однаковий IL-код.



# 19 У чому різниця між структурами та класами в C#?
Структури (`struct`) та класи (`class`) є основними механізмами для створення користувацьких типів в C#, але між ними є ключові відмінності:

1. **Категорія типу:**
   - Структури є **типами значень**.
   - Класи є **типами посилань**.

2. **Розташування в пам'яті:**
   - Екземпляри структур зазвичай розміщуються в **стеку** (або всередині іншого типу значення або типу посилання, де вони оголошені).
   - Екземпляри класів завжди розміщуються в **керованій купі (heap)**.

3. **Присвоєння та передача:**
   - При присвоєнні або передачі структури копіюється її **значення**.
   - При присвоєнні або передачі класу копіюється **посилання** на об'єкт.

4. **Успадкування:**
   - Структури не підтримують успадкування від інших структур або класів. Вони можуть лише реалізовувати інтерфейси. Усі структури неявно є похідними від `System.ValueType`.
   - Класи підтримують одиничне успадкування від іншого класу (базового класу). Вони також можуть реалізовувати кілька інтерфейсів. Усі класи неявно або явно є похідними від `System.Object`.

5. **Значення `null`:**
   - За замовчуванням структури не можуть мати значення `null` (якщо вони не оголошені як `Nullable<T>`).
   - Змінним типу класу за замовчуванням присвоюється значення `null`, якщо їм не присвоєно посилання на об'єкт.

6. **Конструктори за замовчуванням:**
   - Структури мають неявний конструктор за замовчуванням без параметрів, який ініціалізує всі поля значеннями за замовчуванням (0 для числових типів, `false` для `bool`, `\0` для `char` тощо). Ви не можете явно визначити конструктор без параметрів для структури. Ви можете визначати параметризовані конструктори.
   - Класи можуть мати конструктор за замовчуванням без параметрів (який може бути неявним, якщо не визначено жодних інших конструкторів, або явним). Вони також можуть мати параметризовані конструктори.

7. **Фіналізатори:**
   - Структури не можуть мати фіналізатори (деструктори).
   - Класи можуть мати фіналізатори для виконання очищення ресурсів перед тим, як об'єкт буде видалено збирачем сміття.

---
## Коли використовувати структури, а коли класи:

- **Структури:**
  - Використовуйте для представлення невеликих типів значень, які мають семантику значення (тобто копіювання значення є бажаною поведінкою), є незмінними або майже незмінними, та не потребують успадкування.
  - **Приклади:** геометричні точки, кольори, невеликі числові типи.

- **Класи:**
  - Використовуйте для представлення більш складних об'єктів, які мають стан, поведінку, потребують успадкування або передаються за посиланням, ідентичність об'єкта має значення.
  - **Приклади:** вікна, контролери, сутності бази даних.

---

## Продуктивність:

- Використання типу значення замість типу посилання може покращити продуктивність за рахунок зменшення кількості виділень пам'яті в купі та операцій з посиланнями.
- Однак, копіювання великих структур може бути дорожчим, ніж копіювання посилання на об'єкт.
- Рішення слід приймати з урахуванням конкретних вимог до продуктивності та семантики типу.

# 20 У чому різниця між стеком і купою (heap)?

Стек (Stack) та купа (Heap) – це дві різні області пам'яті, які використовуються програмою під час виконання.

---

## Стек (Stack):

- **Використання:**  
  Використовується для зберігання типів значень, локальних змінних, параметрів методів, а також адрес повернення при викликах методів.
- **Організація:**  
  Організований як LIFO (Last-In, First-Out) – останні дані, розміщені в стеку, видаляються першими.
- **Управління пам'яттю:**  
  Управління пам'яттю в стеку є автоматичним та дуже швидким. Пам'ять для локальних змінних виділяється при вході в метод і звільняється при виході з нього.
- **Розмір:**  
  Розмір стеку зазвичай є обмеженим.

---

## Купа (Heap):

- **Використання:**  
  Використовується для зберігання типів посилань – об'єктів класів, масивів, рядків тощо.
- **Управління пам'яттю:**  
  Управління пам'яттю в купі є більш складним і здійснюється збирачем сміття (garbage collector). Пам'ять для об'єктів виділяється за запитом (за допомогою оператора `new`), і об'єкти залишаються в купі до тих пір, поки на них є хоча б одне активне посилання в програмі. Коли об'єкт стає недосяжним, збирач сміття зрештою звільняє займану ним пам'ять.
- **Розмір:**  
  Розмір купи зазвичай є значно більшим за розмір стеку.
- **Швидкість:**  
  Виділення та звільнення пам'яті в купі відбувається повільніше, ніж у стеку.

---

## Основні відмінності:

| **Характеристика**         | **Стек (Stack)**                          | **Купа (Heap)**                          |
|----------------------------|------------------------------------------|------------------------------------------|
| **Що зберігається**        | Типи значень, локальні змінні, параметри методів, адреси повернення | Типи посилань (об'єкти класів, масиви, рядки тощо) |
| **Організація**            | LIFO (останній прийшов — перший пішов)   | Довільна                                 |
| **Управління пам'яттю**    | Автоматичне, швидке                      | Збирач сміття, повільніше                |
| **Розмір**                 | Обмежений                                | Значно більший                           |
| **Швидкість виділення/звільнення** | Швидко                                 | Повільніше                               |

---

## Приклади:

```csharp
public class MyClass
{
    public int Value { get; set; }
}

public struct MyStruct
{
    public int Value { get; set; }
}

public static void MyMethod()
{
    int localVarInt = 10; // localVarInt розміщується в стеку
    MyStruct localVarStruct = new MyStruct { Value = 20 }; // localVarStruct розміщується в стеку
    MyClass localVarClass = new MyClass { Value = 30 }; // localVarClass (посилання) розміщується в стеку, а об'єкт MyClass - в купі
}
```

У цьому прикладі `localVarInt` та `localVarStruct` розміщуються безпосередньо в стеку при виклику методу `MyMethod()`, а при виході з методу займана ними пам'ять автоматично звільняється. Змінна `localVarClass` (типу посилання) розміщується в стеку, але вона зберігає лише адресу об'єкта `MyClass`, який створюється в купі. Пам'ять, займана цим об'єктом в купі, буде звільнена збирачем сміття пізніше, коли на нього не залишиться жодних активних посилань.

# 21. Що таке приведення типів? Яка різниця між явним і неявним приведенням типів?

Приведення типів (Type Casting) – це процес перетворення значення одного типу даних на значення іншого типу даних. В C# приведення типів може бути **явним** або **неявним**.

---

## Неявне приведення типів (Implicit Casting):

- **Відбувається автоматично** компілятором без необхідності явного зазначення оператора приведення.
- **Дозволяється**, коли немає ризику втрати даних або точності, а також коли один тип повністю вміщує діапазон значень іншого типу.  
  Зазвичай це відбувається при перетворенні з "вужчого" типу на "ширший" тип.

### Приклади:
- `int` в `long` (int має менший діапазон, ніж long).
- `byte` в `short`, `int`, `long`, `float`, `double`, `decimal`.
- Прямокутник у його базовий клас (якщо такий існує).

---

## Явне приведення типів (Explicit Casting):

- **Вимагає явного зазначення оператора приведення** (зазвичай у круглих дужках `(targetType)`) перед значенням, яке потрібно перетворити.
- **Необхідне**, коли є ризик втрати даних або точності, або коли компілятор не може гарантувати безпеку перетворення.  
  Зазвичай це відбувається при перетворенні з "ширшого" типу на "вужчий" тип.
- Якщо явне приведення призводить до втрати даних (наприклад, при перетворенні `double` на `int`), відбувається **усічення дробової частини**.
- Якщо явне приведення між несумісними типами є неможливим, під час виконання може виникнути виняток `InvalidCastException`.

### Приклади:
- `double` в `int` (може втратитися дробова частина).
- `long` в `int` (може вийти за межі діапазону int).
- Базовий клас до похідного класу (потрібна перевірка типу).

---

## Оператори явного та неявного перетворення:

Оператори явного та неявного перетворення також можуть бути визначені користувачем для власних типів (класів та структур) за допомогою ключових слів `implicit` (для неявних перетворень) та `explicit` (для явних перетворень).

