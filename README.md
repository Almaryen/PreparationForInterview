# 1 Основні принципи ООП та їх реалізація в C#

Об'єктно-орієнтоване програмування (ООП) базується на чотирьох основних принципах: **інкапсуляція**, **наслідування**, **поліморфізм** та **абстракція**. Розгляньмо кожен із них та їх реалізацію в мові C#.

---

## 1. Інкапсуляція

**Інкапсуляція** передбачає об'єднання даних (полів) та методів, які працюють з цими даними, в одному класі, приховуючи внутрішню реалізацію від зовнішнього світу. Це забезпечує контроль доступу до даних і захист від некоректного використання.

### Реалізація в C#:

У C# для керування доступом використовуються модифікатори доступу: `public`, `private`, `protected` та `internal`. Наприклад:

```csharp
public class BankAccount
{
    private decimal balance; // поле приховане від зовнішнього доступу

    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            balance += amount;
        }
    }

    public decimal GetBalance()
    {
        return balance;
    }
}
```

У цьому прикладі поле `balance` є приватним, і доступ до нього здійснюється через публічні методи `Deposit` та `GetBalance`.

---

## 2. Наслідування

**Наслідування** дозволяє створювати нові класи на основі існуючих, успадковуючи їхні властивості та методи. Це сприяє повторному використанню коду та створенню ієрархій класів.

### Реалізація в C#:

У C# наслідування реалізується за допомогою двокрапки `:`. Наприклад:

```csharp
public class Animal
{
    public void Eat() => Console.WriteLine("Їсть...");
}

public class Dog : Animal
{
    public void Bark() => Console.WriteLine("Гавкає!");
}
```

---

## 3. Поліморфізм

**Поліморфізм** означає, що одна й та сама дія може виконуватись по-різному залежно від об’єкта. Це дозволяє створювати більш гнучкий та масштабований код.

### Реалізація в C#:

C# підтримує як **перевизначення методів** (`virtual` / `override`), так і **інтерфейси**.

```csharp
public class Animal
{
    public virtual void Speak() => Console.WriteLine("Звук тварини");
}

public class Cat : Animal
{
    public override void Speak() => Console.WriteLine("Мяу");
}
```

---

## 4. Абстракція

**Абстракція** дозволяє приховати складність реалізації та показати лише важливу частину функціональності.

### Реалізація в C#:

Використовуються **абстрактні класи** або **інтерфейси**.

```csharp
public abstract class Shape
{
    public abstract double GetArea();
}

public class Circle : Shape
{
    public double Radius { get; set; }
    public override double GetArea() => Math.PI * Radius * Radius;
}
```

---

## Висновок

| Принцип       | Реалізація в C#                                     |
|---------------|-----------------------------------------------------|
| Інкапсуляція  | Модифікатори доступу (`private`, `public` і т.д.)  |
| Наслідування  | Наслідування класів за допомогою `:`               |
| Поліморфізм   | `virtual`, `override`, інтерфейси                   |
| Абстракція    | `abstract` класи, інтерфейси (`interface`)          |


# 2. Як ці принципи реалізовані в C#?
1. **Інкапсуляція**: реалізується через модифікатори доступу (`public`, `private`, `protected`, `internal`), які контролюють видимість членів класу.

2. **Успадкування**: використовується двокрапка `:` для вказівки базового класу.

3. **Поліморфізм**: досягається через використання ключових слів `virtual` та `override` для перевизначення методів, а також через інтерфейси.

4. **Абстракція**: реалізується за допомогою абстрактних класів (`abstract`) та інтерфейсів (`interface`), які визначають загальні методи та властивості для класів-нащадків.

# 3. Які проблеми вирішуються підходом ООП?
- **Модульності**: код розбивається на окремі класи, що спрощує його підтримку та повторне використання.
- **Зрозумілості**: структура коду відображає реальні об'єкти та їх взаємодії, що полегшує розуміння.
- **Гнучкості та масштабованості**: легко додавати нові функціональності без значних змін існуючого коду.

# 4. Які недоліки ООП?
- **Перевитрати ресурсів**: створення об'єктів та використання динамічної диспетчеризації може споживати більше пам'яті та часу виконання.
- **Складність**: неправильне проектування класів та їх взаємодій може призвести до заплутаного коду.
- **Надмірність**: іноді для простих задач використання ООП може бути надлишковим.

# 5. Поясніть концепцію інкапсуляції в об'єктно-орієнтованому програмуванні та як її реалізувати за допомогою C#.
Інкапсуляція передбачає приховування внутрішнього стану об'єкта та надання доступу до нього лише через публічні методи. У C# це реалізується за допомогою модифікаторів доступу:

```csharp
public class BankAccount
{
    private decimal balance; // приховане поле

    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            balance += amount;
        }
    }
     public decimal GetBalance()
    {
        return balance;
    }
}
```

---
# 6. Що таке абстрактний клас? І чим відрізняється від звичайного класу?

**Абстрактний клас** — це клас, який не можна створити (інстанціювати) напряму. Він слугує шаблоном для інших класів і може містити як **реалізовані методи**, так і **абстрактні методи** (тобто без реалізації), які мають бути реалізовані в похідних класах.

### Приклад:

```csharp
public abstract class Animal
{
    public void Eat() => Console.WriteLine("Їсть");

    public abstract void MakeSound(); // без реалізації
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Гав!");
    }
}
```

### Відмінності від звичайного класу:

| Критерій                 | Абстракційний клас                         | Звичайний клас                    |
|--------------------------|--------------------------------------------|-----------------------------------|
| **Можна створювати об'єкти?** | ❌ Ні                                       | ✅ Так                             |
| **Може містити абстрактні методи?** | ✅ Так                                     | ❌ Ні                              |
| **Може містити реалізацію методів?** | ✅ Так                                     | ✅ Так                             |
| **Призначення**          | Базовий клас, що задає інтерфейс/поведінку | Самостійний клас для використання |
| **Ключове слово**        | `abstract`                                 | не потрібне                       |



# 7 Інтерфейси та їх відмінності від абстрактних класів у C#

**Інтерфейс** — це тип, який визначає контракт для класів або структур, що його реалізують. Він описує набір методів та властивостей, які повинні бути реалізовані в класах або структурах, але не містить реалізації цих методів.

**Основні відмінності між інтерфейсом та абстрактним класом:**

1. **Множинне успадкування:**
   - **Інтерфейс:** Клас може реалізовувати кілька інтерфейсів, що дозволяє досягати множинного успадкування.
   - **Абстрактний клас:** Клас може успадковувати лише від одного абстрактного класу, оскільки C# підтримує лише одиничне успадкування класів.

2. **Модифікатори доступу:**
   - **Інтерфейс:** Усі члени інтерфейсу за замовчуванням є `public`. Починаючи з C# 8.0, інтерфейси можуть містити приватні методи, але інші модифікатори доступу, такі як `protected` або `internal`, все ще не підтримуються для членів інтерфейсу.
   - **Абстрактний клас:** Може використовувати різні модифікатори доступу (`public`, `private`, `protected`, `internal`) для своїх членів.

3. **Реалізація методів:**
   - **Інтерфейс:** Може містити тільки оголошення методів без реалізації (до C# 8.0). Починаючи з C# 8.0, інтерфейси можуть містити методи з реалізацією за замовчуванням.
   - **Абстрактний клас:** Може містити як абстрактні методи (без реалізації), так і методи з реалізацією.

4. **Поля та дані:**
   - **Інтерфейс:** Не може містити поля даних. Може містити лише статичні константи.
   - **Абстрактний клас:** Може містити поля даних будь-якого типу.

5. **Конструктори:**
   - **Інтерфейс:** Не може мати конструкторів.
   - **Абстрактний клас:** Може мати конструктори, які можуть бути викликані з конструкторів похідних класів.

6. **Призначення використання:**
   - **Інтерфейс:** Використовується для визначення спільного контракту для різних класів, які можуть не мати спільної реалізації. Це підходить для опису поведінки, яку можуть мати різні, непов'язані між собою класи.
   - **Абстрактний клас:** Використовується, коли є спільна базова реалізація, яку слід розділяти серед похідних класів. Це підходить для створення ієрархій типів з спільними властивостями та методами.

**Приклад використання інтерфейсу та абстрактного класу:**

```csharp
// Інтерфейс
public interface IFlyable
{
    void Fly();
}

// Абстрактний клас
public abstract class Animal
{
    public string Name { get; set; }

    public void Eat()
    {
        Console.WriteLine($"{Name} їсть.");
    }

    public abstract void MakeSound();
}

// Клас, що реалізує інтерфейс та успадковує абстрактний клас
public class Bird : Animal, IFlyable
{
    public Bird(string name)
    {
        Name = name;
    }

    public override void MakeSound()
    {
        Console.WriteLine($"{Name} співає.");
    }

    public void Fly()
    {
        Console.WriteLine($"{Name} летить.");
    }
}
```



# 8 Ключове слово `virtual` у C#

У мові програмування C# ключове слово `virtual` використовується в об'єктно-орієнтованому програмуванні для позначення членів класу, які можуть бути перевизначені (overridden) у похідних класах. Воно є основою для реалізації поліморфізму, дозволяючи похідним класам надавати власну реалізацію методів або властивостей базового класу.

## Що дає ключове слово `virtual`?
1. **Поліморфізм**: Дозволяє викликати перевизначену версію методу або властивості з похідного класу через посилання на базовий клас.
2. **Гнучкість**: Надає можливість похідним класам змінювати або розширювати поведінку базового класу.
3. **Пізнє зв’язування**: Забезпечує вибір реалізації під час виконання програми (runtime), а не під час компіляції.

## Які члени класу можуть бути позначені модифікатором `virtual`?
У C# ключове слово `virtual` може застосовуватися до таких членів класу:
1. **Методи**:
   - Звичайні методи класу, які можуть бути перевизначені в похідних класах за допомогою ключового слова `override`.
   - Наприклад:
     ```csharp
     public class BaseClass
     {
         public virtual void Display()
         {
             Console.WriteLine("Base class");
         }
     }
     ```

2. **Властивості**:
   - Властивості (properties) можуть бути віртуальними, дозволяючи похідним класам перевизначати їхню поведінку (геттери та сеттери).
   - Наприклад:
     ```csharp
     public class BaseClass
     {
         public virtual int MyProperty { get; set; }
     }
     ```

3. **Індексатори**:
   - Індексатори (indexers) також можуть бути позначені як `virtual`, щоб дозволити їх перевизначення.
   - Наприклад:
     ```csharp
     public class BaseClass
     {
         protected int[] data = new int[10];
         public virtual int this[int index]
         {
             get => data[index];
             set => data[index] = value;
         }
     }
     ```

4. **Обмеження**:
   - Конструктори **не можуть** бути віртуальними, оскільки вони викликаються під час створення об’єкта і не беруть участі в поліморфізмі.
   - Деструктори (фіналізатори) у C# **не можуть** бути віртуальними, на відміну від C++, оскільки в C# управління пам’яттю здійснюється через збірник сміття (Garbage Collector), і деструктори мають іншу семантику.
   - Статичні члени (методи, властивості тощо) **не можуть** бути віртуальними, оскільки вони належать класу, а не екземпляру.

## Особливості в C#
- У похідному класі для перевизначення віртуального члена використовується ключове слово `override`. Наприклад:
  ```csharp
    public class DerivedClass : BaseClass
    {
        public override void Display()
        {
            Console.WriteLine("Derived class");
        }
    }
  ```
  Якщо член позначений як virtual, він може бути перевизначений лише за допомогою override. Без virtual члени за замовчуванням не є поліморфними в C# (на відміну від деяких інших мов, наприклад, Java).

Ключове слово virtual не можна комбінувати з static, abstract або private, оскільки ці модифікатори суперечать його призначенню.

### Висновок
У C# virtual є важливим інструментом для створення гнучких ієрархій класів, дозволяючи перевизначати методи, властивості та індексатори в похідних класах. Це забезпечує поліморфізм і розширюваність коду.



# 9 Яка різниця між перевантаженням методу та перевизначенням методу?

У мові програмування C# перевантаження (overloading) і перевизначення (overriding) методів є двома різними концепціями, які часто плутають через схожість термінів. Вони мають різні цілі, механізми та правила використання. Розглянемо їх детально.

## Перевантаження методу (Method Overloading)
Перевантаження методу — це створення кількох методів з однаковою назвою, але різними сигнатурами (кількістю, типами параметрів або їх порядком) у межах одного класу.

## Основні характеристики:
1. **Місце визначення**: Відбувається в межах одного класу.
2. **Сигнатура**: Методи відрізняються за параметрами (кількість, тип або порядок), але можуть мати однаковий тип повернення.
3. **Поліморфізм**: Є прикладом статичного (компіляційного) поліморфізму, оскільки вибір методу відбувається під час компіляції.
4. **Модифікатори**: Не потребує спеціальних ключових слів, таких як `virtual` чи `override`.

```csharp
   public class Calculator
   {
       public int Add(int a, int b)
       {
           return a + b;
       }

       public double Add(double a, double b)
       {
           return a + b;
       }

       public int Add(int a, int b, int c)
       {
           return a + b + c;
       }
   }
```
   У цьому прикладі метод Add перевантажений трьома різними способами.
   
## Коли використовувати?
- Коли потрібно виконувати схожу логіку з різними типами або кількістю вхідних даних.

## Перевизначення методу (Method Overriding)
Перевизначення методу — це зміна або розширення реалізації методу базового класу в похідному класі. Воно пов’язане з успадкуванням і поліморфізмом.

### Основні характеристики:
1. Місце визначення: Відбувається в похідному класі для методу, визначеного в базовому класі.
2. Сигнатура: Метод у похідному класі повинен мати таку саму сигнатуру (назву, параметри, тип повернення), як у базовому класі.
3. Поліморфізм: Є прикладом динамічного (виконавчого) поліморфізму, оскільки вибір методу відбувається під час виконання програми.
4. Модифікатори: У базовому класі метод позначається як virtual, а в похідному — перевизначається за допомогою override.

```csharp
  public class Animal
  {
      public virtual void MakeSound()
      {
          Console.WriteLine("Some generic sound");
      }
  }
  
  public class Dog : Animal
  {
      public override void MakeSound()
      {
          Console.WriteLine("Woof!");
      }
  }
```
У цьому прикладі метод MakeSound перевизначений у класі Dog.

## Коли використовувати?
- Коли потрібно змінити або розширити поведінку методу базового класу в похідному класі.

## Основні відмінності

| **Характеристика**         | **Перевантаження (Overloading)**         | **Перевизначення (Overriding)**         |
|----------------------------|------------------------------------------|-----------------------------------------|
| **Місце дії**             | У межах одного класу                    | Між базовим і похідним класами          |
| **Сигнатура**             | Різні параметри (кількість, тип)        | Та сама сигнатура                      |
| **Тип поліморфізму**      | Статичний (компіляційний)               | Динамічний (виконавчий)                |
| **Ключові слова**         | Не потрібні                             | `virtual` (базовий), `override` (похідний) |
| **Успадкування**          | Не залежить від успадкування            | Потребує успадкування                  |
| **Приклад виклику**       | `Add(1, 2)` vs `Add(1.0, 2.0)`          | `animal.MakeSound()` (залежить від типу об’єкта) |


## Висновок
- Перевантаження дозволяє створювати кілька версій методу з різними параметрами для зручності використання в одному класі.
- Перевизначення дозволяє адаптувати поведінку методу базового класу до потреб похідного класу, забезпечуючи поліморфізм.
Обидва підходи є важливими інструментами в C#, але вони вирішують різні задачі та застосовуються в різних контекстах.

